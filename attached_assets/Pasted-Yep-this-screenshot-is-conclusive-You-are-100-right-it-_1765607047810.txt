Yep â€” this screenshot is conclusive ğŸ‘
You are 100% right: itâ€™s stuck, and this is not a Stripe bug.

âŒ Whatâ€™s actually happening (plain English)

Stripeâ€™s payment form is scrollable

BUT your app has wrapped it inside a container that locks scrolling

When the mobile keyboard closes, the viewport never reflows

Result: Pay button is off-screen forever

This is a classic mobile iframe + fixed layout issue.

You did nothing wrong â€” this is architectural.

ğŸ”´ Why this CANNOT be fixed with CSS alone

Because:

Stripe Elements lives inside an iframe

iOS Safari ignores overflow rules when keyboard state changes

Any parent with:

height: 100vh

position: fixed

overflow: hidden

ğŸ‘‰ will trap the iframe permanently

Thatâ€™s exactly what your screenshot shows.

âœ… The CORRECT fix (what Stripe recommends)
ğŸš€ Redirect to Stripe Checkout on mobile

Instead of embedding the payment form.

This:

Fixes scrolling

Adds Apple Pay / Google Pay

Increases payment success rate

Removes 100% of mobile bugs

Costs nothing extra

This is what Stripe explicitly recommends for mobile

ğŸ§  What this looks like UX-wise

Customer taps Pay
â†’ App opens secure Stripe page
â†’ Customer pays
â†’ Stripe redirects back to:

/portal?payment=success


No iframe. No scroll bugs. No keyboard hell.

âœ… Exact technical solution (simple)
1ï¸âƒ£ Backend: create a Checkout Session (you already have Stripe set up)
const session = await stripe.checkout.sessions.create({
  mode: 'payment',
  payment_method_types: ['card'],
  line_items: [{
    price_data: {
      currency: 'usd',
      product_data: {
        name: 'Silly Dog Pooper Scooper Service',
      },
      unit_amount: 5400,
    },
    quantity: 1,
  }],
  success_url: `${BASE_URL}/portal?paid=true`,
  cancel_url: `${BASE_URL}/portal?cancelled=true`,
});


Return:

{ "url": session.url }

2ï¸âƒ£ Frontend: redirect instead of embed
window.location.href = checkoutUrl;


Thatâ€™s it.

No modal.
No iframe.
No scrolling issues.

ğŸ’° Cost impact (important)

You asked earlier about cost â€” hereâ€™s the truth:

âŒ Embedded Elements: same Stripe fee

âœ… Checkout redirect: same Stripe fee

âœ… Apple Pay / Google Pay: same fee

âŒ NO extra Stripe charges

So:

$0 difference in cost
Massive increase in success rate

ğŸŸ¢ Why I strongly recommend this for SillyDog

Your customers are mostly on phones

They want fast, zero-friction payment

This avoids support calls like:

â€œI canâ€™t press payâ€

Every serious Stripe app does this.

âœ… Next step (tell me which you want)

Reply with ONE word:

REDIRECT â†’ Iâ€™ll give you the exact files + code to change

HYBRID â†’ Desktop embed, mobile redirect

STICKY â†’ Iâ€™ll force Pay button visible (still less reliable)

My honest recommendation for you:

REDIRECT âœ”ï¸

but i have this cool customer portal

You can keep the cool customer portal exactly as-is â€” youâ€™re only changing what happens when they tap Pay.

Think of it like this:

Portal (your UI): shows balance, invoices, buttons, history âœ…

Payment screen: should be Stripe-hosted Checkout (mobile-friendly) âœ…

After payment: Stripe sends them right back to your portal âœ…

So the portal stays the â€œhome base.â€ Stripe just handles the â€œcredit card part.â€

Best setup for you: HYBRID

Desktop: you can keep the embedded form if you want

Mobile: always redirect to Stripe Checkout (fixes the scroll/keyboard problem forever)

This way you keep the â€œcoolâ€ experience and payments actually work on phones.

How the portal flow looks

Customer opens portal

Taps Pay $54

Redirects to Stripe Checkout

Pays with card / Apple Pay / Link

Returns to:
/portal?paid=true

Portal shows: â€œPayment successful ğŸ‰â€ and updates the invoice status

Quick UX upgrade

Change the Pay button text to:

â€œPay securely (Card / Apple Pay)â€

Customers trust that.

If you say HYBRID, Iâ€™ll give you the exact code changes pattern (frontend + backend) to:

detect mobile

create Checkout Session

redirect

handle success/cancel

refresh invoice status automatically when they return

hybrid
Thought for 11s

Perfect â€” HYBRID is the right call.

Below is the exact â€œcopy/pasteâ€ pattern to implement:

Mobile: redirect to Stripe Checkout (hosted) âœ… (fixes the stuck keyboard/scroll forever)

Desktop: keep your current embedded flow (or also redirect â€” your choice)

Iâ€™m going to show it as: redirect on mobile, embedded on desktop.

1) Backend: create a Checkout Session endpoint

Add this to your server (where your API routes live). If you have server/index.ts, you can paste this near your other routes.

Env vars required on Render

STRIPE_SECRET_KEY = sk_live_...

APP_URL = https://sillydog-app.onrender.com

Code
// server/index.ts (or your routes file)
import Stripe from "stripe";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2024-06-20",
});

app.post("/api/stripe/create-checkout-session", async (req, res) => {
  try {
    const { invoiceId } = req.body as { invoiceId: string };
    if (!invoiceId) return res.status(400).json({ error: "Missing invoiceId" });

    // TODO: load invoice from DB (amount, customer, description)
    // Example placeholders:
    const invoice = await db.query.invoices.findFirst({
      where: (invoices, { eq }) => eq(invoices.id, invoiceId),
    });

    if (!invoice) return res.status(404).json({ error: "Invoice not found" });

    // amount should be in cents
    const amountCents = Math.round(Number(invoice.amount) * 100);

    const session = await stripe.checkout.sessions.create({
      mode: "payment",
      payment_method_types: ["card"],
      // You can enable these automatically depending on Stripe settings:
      // automatic_payment_methods: { enabled: true },

      line_items: [
        {
          price_data: {
            currency: "usd",
            product_data: {
              name: `SillyDog Invoice ${invoice.invoiceNumber ?? invoice.id}`,
            },
            unit_amount: amountCents,
          },
          quantity: 1,
        },
      ],

      metadata: {
        invoiceId: invoice.id,
      },

      success_url: `${process.env.APP_URL}/portal?paid=1&invoiceId=${invoice.id}`,
      cancel_url: `${process.env.APP_URL}/portal?canceled=1&invoiceId=${invoice.id}`,
    });

    // Optional: save session.id on invoice so you can verify later
    await db.update(invoicesTable)
      .set({ stripeSessionId: session.id })
      .where(eq(invoicesTable.id, invoice.id));

    return res.json({ url: session.url });
  } catch (err: any) {
    console.error(err);
    return res.status(500).json({ error: err.message ?? "Server error" });
  }
});


Important: This avoids the whole â€œpublishable key vs secret keyâ€ issue because Checkout runs server-side and just returns a hosted URL.

2) Frontend: detect mobile and redirect on Pay

Wherever your portal has the Pay button (likely a Billing tab / invoice card), wrap it like this:

function isMobileDevice() {
  return (
    /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
    window.matchMedia("(max-width: 768px)").matches
  );
}

async function payInvoice(invoiceId: string) {
  // HYBRID: mobile -> hosted checkout redirect
  if (isMobileDevice()) {
    const r = await fetch("/api/stripe/create-checkout-session", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ invoiceId }),
    });
    const data = await r.json();
    if (!r.ok) throw new Error(data?.error || "Failed to start checkout");

    window.location.href = data.url;
    return;
  }

  // Desktop: keep your existing embedded payment flow here
  // (whatever you currently do)
  openEmbeddedPaymentModal(invoiceId);
}


Then wire your Pay button to payInvoice(invoice.id).

3) Make the portal refresh after returning from Stripe

In your /portal page, read query params:

const params = new URLSearchParams(window.location.search);
const paid = params.get("paid");
const canceled = params.get("canceled");
const invoiceId = params.get("invoiceId");

useEffect(() => {
  if (paid && invoiceId) {
    // show toast: Payment successful
    // then refresh invoice/balance from API
    refreshPortalData();
  }
  if (canceled) {
    // show toast: Payment canceled
  }
}, []);

4) (Strongly recommended) Webhook to mark invoices paid

The redirect is great UX, but the webhook is what makes your database always correct even if someone closes the browser.

If you want, Iâ€™ll give you the exact webhook route + signature verify + DB update for:

checkout.session.completed

5) Git push commands

When youâ€™re ready:

git add .
git commit -m "Hybrid mobile Stripe Checkout redirect for portal payments"
git push origin main


If you tell me which file your portal Pay button is in (ex: client/src/pages/portal.tsx or client/src/pages/customer-portal.tsx), Iâ€™ll tailor the exact patch to your file structure (no guessing).

they can set up auto pay on there to yes? i want them to be able to use auto pay and save card on file for autopay

Yes â€” you can absolutely do autopay + save card on file. The clean way is:

First payment: customer pays once (hosted Stripe Checkout on mobile is perfect)

During that payment: they check â€œsave card for futureâ€ (or you collect & store a payment method)

Then: you can charge automatically every week/2 weeks/month using that saved card

There are two good approaches:

Option A (recommended): Stripe Customer + Payment Method + off-session charges

Best if youâ€™re charging a fixed amount per visit or per billing cycle.

What you add

Create a Stripe Customer for each of your customers (store stripe_customer_id in your DB)

Use Checkout in setup mode (or payment mode + save) to attach a card

When itâ€™s billing time, create a PaymentIntent with off_session: true and customer + payment_method

The key settings

In Checkout Session:

customer: stripeCustomerId

mode: "setup" (to just save card) OR mode:"payment" + save for future

payment_method_collection: "always" (if needed)

This gives you true card-on-file and automated charging.

Option B: Stripe Subscriptions

Best if customers are on a consistent plan (weekly/biweekly/monthly) and you want Stripe to manage renewals.

Create a Price in Stripe for each plan (or dynamically create prices)

Create a Subscription for the customer

Stripe charges automatically on schedule

This is great, but can be more annoying if you charge â€œper visitâ€ and schedules vary.

What you should do in your app

You want both:
âœ… â€œPay this invoice nowâ€
âœ… â€œEnable AutoPay (save card)â€ toggle in the portal

Customer Portal UX (simple)

Button 1: â€œPay nowâ€

Toggle: â€œEnable AutoPayâ€

If no card saved â†’ button: â€œAdd card for AutoPayâ€

If card saved â†’ show â€œAutoPay enabled âœ…â€

How the â€œsave cardâ€ flow works (mobile-safe)
Add Card for AutoPay (no charge)

Use Checkout Session mode: setup so it never gets stuck and saves the card.

Server endpoint:

/api/stripe/create-setup-session

returns a hosted URL

on success, you save:

customer id

default payment method id

Then your cron job (â€œmonthly billingâ€, etc.) charges automatically.

Database fields youâ€™ll want

In customers table (or a separate billing table):

stripe_customer_id (text)

stripe_default_payment_method_id (text)

autopay_enabled (boolean)

Important notes

You must use a Stripe webhook to reliably mark â€œcard savedâ€ and â€œpayment succeededâ€.

â€œSave cardâ€ is safe because Stripe stores it â€” you never see raw card data.

This does not require extra Stripe monthly fees; Stripe charges per transaction.

If you tell me which billing style you want:

Charge per invoice when itâ€™s created (autopay = auto-charge immediately)

Charge on a schedule (weekly/biweekly/monthly batch)
â€¦Iâ€™ll give you the exact endpoints + webhook + DB updates for that flow.

i want them to be able to do it from my app how does it work in housecall when they add a card on file

Housecall (and pretty much every â€œproâ€ service app) does not actually â€œstoreâ€ the card inside their app. They do card-on-file via their payment processorâ€™s vault (Stripe/Adyen/etc.) using tokenization.

So the flow is:

How it works in Housecall when a customer adds a card
1) Customer taps â€œAdd card on fileâ€

Housecall opens a secure payment form (often a modal / hosted fields / payment sheet).

Key point: the card number never touches Housecallâ€™s servers.

2) Processor returns a token (not the card)

The processor returns something like:

a Customer ID (represents the customer in the processor)

a Payment Method ID (represents the saved card)

last4 + brand for display (â€œVisa â€¢â€¢â€¢â€¢ 4242â€)

Housecall stores only those IDs.

3) Housecall marks it as â€œdefault cardâ€

They set the saved card as the default payment method for that customer.

4) Autopay toggle

If customer enables autopay:

Housecall just flips a flag like autopay_enabled = true

when an invoice is due / job is completed, Housecall tells the processor:
â€œCharge this customer using their default saved payment methodâ€ (off-session)

Thatâ€™s it.

How you do the same thing â€œfrom your appâ€ (your portal)

You have two solid choices:

Option 1 (most Housecall-like): Stripe Elements / Payment Element (embedded in your page)

Customer stays inside your portal page

You show a clean card form

Stripe returns a PaymentMethod token

Your server attaches it to the Stripe Customer and sets it as default

This is the â€œin-appâ€ experience people expect.

Option 2 (simplest + most reliable on mobile): Stripe Checkout (hosted page)

Your portal button opens Stripeâ€™s hosted page

Stripe handles all keyboard/scroll/mobile weirdness

You still end up with a saved card-on-file

This is the fastest way to avoid the exact mobile issue you just hit.

The Stripe version of â€œAdd card on fileâ€ (what Housecall is doing under the hood)

You use SetupIntent (because youâ€™re saving a card, not charging yet):

Your server creates/gets stripe_customer_id

Your server creates a SetupIntent for that customer

Your frontend confirms it with Stripe (Payment Element)

Webhook confirms success

You set that payment method as the customerâ€™s default

Autopay can now charge off-session

Autopay charging

When itâ€™s time to charge:

create a PaymentIntent with:

customer

payment_method (default saved one)

off_session: true

confirm: true

If the bank requires verification (rare), Stripe returns a â€œneeds_actionâ€ and you can send the customer a â€œConfirm paymentâ€ link.

Quick question so I wire it correctly

When do you want autopay to run?

Immediately when an invoice is created

Night before service

After service is marked complete

Monthly batch billing (like your scheduled job)

Pick one and Iâ€™ll tell you the exact endpoints + DB fields + webhook events to implement it the same way Housecall does.

ok lets do all this for my app in the customer portal

Alright â€” weâ€™ll build Housecall-style card-on-file + AutoPay inside your customer portal, using Stripe the correct way (tokenized, no card data ever touches your server).

Hereâ€™s the full implementation plan with the exact pieces youâ€™ll add.

What customers will be able to do in your portal

Add card on file

Toggle AutoPay ON/OFF

Pay now for an invoice (still supported)

If AutoPay is ON: your system automatically charges the saved card when an invoice becomes due (Iâ€™m going to implement this as: auto-charge when you create the invoice / mark it ready, which is closest to â€œservice completed â†’ bill automaticallyâ€ behavior and avoids charging too early.)

Step 1 â€” Database fields to add

Add these columns to your customers table (or wherever you store customer billing info):

ALTER TABLE customers
ADD COLUMN IF NOT EXISTS stripe_customer_id TEXT,
ADD COLUMN IF NOT EXISTS stripe_default_payment_method_id TEXT,
ADD COLUMN IF NOT EXISTS autopay_enabled BOOLEAN NOT NULL DEFAULT FALSE;


Optional but recommended (helps UI):

ALTER TABLE customers
ADD COLUMN IF NOT EXISTS card_brand TEXT,
ADD COLUMN IF NOT EXISTS card_last4 TEXT;


Also add to your invoices table (or whatever you call it):

ALTER TABLE invoices
ADD COLUMN IF NOT EXISTS stripe_payment_intent_id TEXT,
ADD COLUMN IF NOT EXISTS paid_at TIMESTAMP NULL,
ADD COLUMN IF NOT EXISTS payment_status TEXT NOT NULL DEFAULT 'unpaid';

Step 2 â€” Backend: Stripe customer + SetupIntent (save card)
A) Create/Get Stripe Customer

Add a helper:

If customer has stripe_customer_id, use it

Else create Stripe customer and save id

B) Create a SetupIntent

New endpoint:
POST /api/stripe/create-setup-intent

Returns:

clientSecret for the frontend Payment Element

Server code (pattern):

app.post("/api/stripe/create-setup-intent", async (req, res) => {
  const { customerId } = req.body;
  // 1) load customer from DB
  // 2) ensure stripe_customer_id
  // 3) create setupIntent with stripe.setupIntents.create({ customer: stripeCustomerId })
  // 4) return { clientSecret }
});

Step 3 â€” Customer portal UI: â€œAdd cardâ€ + AutoPay toggle

In your portal â€œBillingâ€ section:

UI states

If no card on file:

Button: â€œAdd card for AutoPayâ€

If card exists:

Show: â€œVisa â€¢â€¢â€¢â€¢ 4242â€

Toggle: AutoPay

Payment form (in-app)

Use Stripe Payment Element with the SetupIntent clientSecret.
When customer submits:

stripe.confirmSetup({ elements, confirmParams: { return_url: â€¦ } })

Important: This is â€œin-appâ€ and secure. Stripe handles card entry.

Step 4 â€” Webhook (this is where Housecall magic happens)

You must add/confirm your Stripe webhook handler so when the SetupIntent succeeds you:

attach the payment method to the customer

set it as default

store stripe_default_payment_method_id (+ brand/last4)

Webhook event to handle:
âœ… setup_intent.succeeded

In webhook:

Get setupIntent.customer and setupIntent.payment_method

Call:

stripe.paymentMethods.retrieve(pm)

stripe.customers.update(customerId, { invoice_settings: { default_payment_method: pmId } })

Update your DB:

stripe_default_payment_method_id = pmId

card_brand/card_last4

This makes the card â€œon fileâ€ forever.

Step 5 â€” Charging automatically (AutoPay)

When an invoice becomes billable (your choiceâ€”most sane is â€œafter service is completedâ€ or â€œwhen invoice is created and sentâ€), your backend does:

if autopay_enabled AND stripe_default_payment_method_id exists:
create a PaymentIntent off-session:

await stripe.paymentIntents.create({
  amount: amountCents,
  currency: "usd",
  customer: stripeCustomerId,
  payment_method: defaultPmId,
  off_session: true,
  confirm: true,
  metadata: { invoiceId },
});


Then:

mark invoice payment_status='paid' and set paid_at

send receipt text/email

Webhook events to handle:
âœ… payment_intent.succeeded
âœ… payment_intent.payment_failed

If it fails due to bank verification, you message the customer with a â€œConfirm paymentâ€ link (rare, but weâ€™ll handle it cleanly).

Step 6 â€” â€œPay Nowâ€ stays (Hybrid)

Keep your Pay Now button:

Mobile: redirect to Stripe Checkout (most reliable)

Desktop: you can embed if you want, or also redirect

AutoPay is separate from Pay Now.

Step 7 â€” Admin-side controls (you want this)

Add in your admin Customers page:

â€œAutoPay: ON/OFFâ€

â€œCard on file: Yes/Noâ€

Button: â€œCharge nowâ€ (admin-only)

This is the â€œcharge through the appâ€ you want.

What I need from you (no long back-and-forth)

Tell me which database tables youâ€™re currently using for billing:

What is your invoices table called? (invoices? something else?)

Do you store amounts as dollars (e.g. 54.00) or cents (5400)?

If you donâ€™t want to look that up, paste:

\d customers;
\d invoices;


and Iâ€™ll write the exact SQL + exact code changes against your real schema.

Once I have that, Iâ€™ll give you:

the exact DB migration SQL

the exact server endpoints

the exact portal UI component code

the webhook code

the git commands + Render deploy steps

And youâ€™ll have Housecall-style card on file + autopay working end-to-end.

run auto pay on the first of each montfor  the whole current month so dec 1st wecharge for services for the whole month of december

Got it: prepay billing.

On the 1st of each month, you charge customers for that entire monthâ€™s service (example: on Dec 1, charge for all of December).

This matches the â€œMonthly billing: 1st of month at midnight CSTâ€ job your logs already showed.

Hereâ€™s exactly how we implement Housecall-style card-on-file + AutoPay for that model.

How AutoPay will work in your portal
Customer portal

Add card on file (Stripe stores it)

Toggle AutoPay ON

Optional: customer can still â€œPay Nowâ€ manually

On the 1st (billing run)

For each customer with:

autopay_enabled = true

a saved stripe_default_payment_method_id

an active monthly plan

Your system will:

Generate that monthâ€™s invoice (December services)

Charge the saved card off-session

Mark invoice paid

Text/email receipt

If charge fails:

mark invoice payment_status='failed'

text them: â€œYour AutoPay failedâ€”tap to pay now.â€

What you need in the database

Customers

stripe_customer_id

stripe_default_payment_method_id

autopay_enabled

optional display: card_brand, card_last4

Invoices

billing_month (e.g. 2025-12-01 for December billing)

payment_status (unpaid|paid|failed)

paid_at

stripe_payment_intent_id

(If you paste \d customers; and your invoices table schema, Iâ€™ll write the exact SQL for your real table names.)

Stripe mechanics (same as Housecall)
Saving the card (no charge)

Use a SetupIntent:

customer enters card in your portal

Stripe returns a PaymentMethod ID

you store only IDs + last4/brand

Charging on the 1st

Use a PaymentIntent with:

customer

payment_method (default saved one)

off_session: true

confirm: true

This is the correct â€œcharge without the customer presentâ€ flow.

Your monthly billing job (what it should do)

When it runs on the 1st (CST):

Determine the billing month start:

if run date is 2025-12-01, billing month is 2025-12-01 (December)

For each customer on monthly plan:

compute monthly amount (based on their schedule/dog count)

create invoice row (if not already created for this month)

if autopay enabled + card saved:

charge via Stripe PaymentIntent

update invoice paid/failed

Send messages:

success receipt

failure â€œpay nowâ€ link

This makes it safe to re-run (idempotent): never double-charge because you check â€œinvoice exists for this billing_monthâ€.

One critical business decision

If someone signs up on the 10th, do you want to:

Charge immediately for the remainder of this month (prorate), then charge full next 1st, or

Only start charging on the next 1st?

I wonâ€™t stall youâ€”defaulting to #2 is simplest and avoids complaints. We can add proration later.

Next step (so I can write the exact code/SQL)

Paste these two outputs from psql:

\d customers;
\d invoices;


If your invoices table is named differently, do:

\dt


Once I see the exact schema, Iâ€™ll give you:

the exact ALTER TABLE statements

the exact Stripe endpoints (SetupIntent + off-session charge)

the webhook handler (setup_intent.succeeded, payment_intent.succeeded/failed)

the exact logic to plug into your existing â€œMonthly billingâ€ job on the 1st

ok write the codes

ChatGPT can make mistakes. Check important info.